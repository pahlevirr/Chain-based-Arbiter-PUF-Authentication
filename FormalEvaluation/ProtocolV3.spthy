theory AuthProtocolNoComments

begin

builtins: hashing

functions:
  H/1,
  PUF/2,
  ZK/3,
  XZK/1


/* Here the asumption are placed
    1. ID_j is unique per device

*/
rule P_ID: // Prover_ID_Commit
  [ Fr(~ID_j) ]
  --[ IDCommit(~ID_j) ]->
  [ 
    !Commit($DEVICE, ~ID_j, H(~ID_j))
  ]

rule SessionID:  //  Generate unique session ID - one-time use
  [
    Fr(~sid)
  ]
  --[SessionID(~sid)]->
  [
    Session(~sid)   // Linear - consumed when session starts
  ]

rule SessionRND:    // Generate fresh session random - one-time use
  [
    Fr(~x_p)
  ]
  --[SessionRND(~x_p)]->
  [
    Session_RND(~x_p)   // Linear - consumed when used
  ]

rule SessionCHLEN: // Generate fresh CHlen - one-time use
  [
    Fr(~CHlen)
  ]
  --[SessionCHLEN(~CHlen)]->
  [
    Session_CHLEN(~CHlen)   // Linear - consumed when used
  ]

rule ChallengeGen:  // Generate challenge - one-time use
  [
    Fr(~c)
  ]
  --[ChallengeGen(~c)]->
  [
    Challenge(~c)   // Linear - consumed when used
  ]

rule UniqueGen:  // Generate unique value - one-time use
  [
    Fr(~r)
  ]
  --[UniqueGen(~r)]->
  [
    Unique(~r)   // Linear - consumed when used
  ]


  // Initiate the authentication by Prover sending a HELLO message
rule Prover_Hello:
  [ Session_CHLEN(CHlen),      // 
    Session_RND(x_p),          //
    Session(sid),              // 
    !Commit($DEVICE, ID_j, HID) ]  // Persistent - device identity
  --[ Prover_Hello(ID_j, x_p, sid) ]->
  [ Out(<sid, HID, CHlen, x_p>),
    St_Prover_Hello($DEVICE, ID_j, HID, x_p, sid)  // Linear state
  ]

rule Verifier_Hello:
  [ In(<sid, HID, CHlen, x_p>),
    St_Prover_Hello($DEVICE, ID_j, HID, x_p, sid),  // Consumed
    Challenge(c),              // 
    Unique(r)                  // 
  ]
  --[ Verifier_Hello(ID_j, CHlen, x_p, sid) ]->
  [ Out(<sid, c>),
    St_Verifier_Hello($VERIFIER, $DEVICE, ID_j, HID, c, r, x_p, sid)  // Linear state
  ]
// ---------------------------------------------------------------


// Start the Chain authentication procedure
rule Pr_Chain_1:
  let
    rX   = PUF(c, r)
    x_pv = H(<x_p, ID_j>)
    CHA = H(<rX, c, x_pv>)
  in
  [ In(<sid, c>),
    St_Verifier_Hello($VERIFIER, $DEVICE, ID_j, HID, c, r, x_p, sid)  // Consumed
  ]
  --[ Pr_Chain_1(ID_j, x_pv, rX, sid) ]->
  [ Out(<sid, CHA, HID>),
    St_Pr_Chain_1($DEVICE, $VERIFIER, ID_j, HID, CHA, x_p, x_pv, rX, sid)  // Linear state
  ]

rule Ver_Chain_1:
  let
    ACK = H(<rX, ID_j, x_pv>)
  in
  [ In(<sid, CHA, HID>),
    St_Pr_Chain_1($DEVICE, $VERIFIER, ID_j, HID, CHA, x_p, x_pv, rX, sid),  // Consumed
    Challenge(c1),             // 
    Unique(r1)                 //
  ]
  --[ Ver_Chain_1(ID_j, CHA, sid) ]->
  [ Out(<sid, ACK>),
    St_Ver_Chain_1($VERIFIER, $DEVICE, ID_j, HID, x_p, x_pv, c1, r1, sid)  // Linear state
  ]

rule Pr_Chain_2:
  let
    rX1   = PUF(c1, r1)
    x_pv = H(<x_p, ID_j>)
    CHA1 = H(<rX1, c1, x_pv>)
  in
  [ In(<sid, ACK>),
    St_Ver_Chain_1($VERIFIER, $DEVICE, ID_j, HID, x_p, x_pv, c1, r1, sid)  // Consumed
  ]
  --[ Pr_Chain_2(ID_j, x_pv, rX1, sid) ]->
  [ Out(<sid, CHA1, HID>),
    St_Pr_Chain_2($DEVICE, $VERIFIER, ID_j, HID, CHA1, x_p, x_pv, rX1, sid)  // Linear state
  ]


rule GenerateM:  // Generate M - one-time use
    [
        Fr(~M)
    ]
    --[GenerateM(~M)]->
    [
        Generate_M(~M)   // Linear - consumed when used
    ]

rule Ver_Chain_2:
  let
    ACK = H(<rX1, ID_j, x_pv>)
  in
  [ In(<sid, CHA1, HID>),
    St_Pr_Chain_2($DEVICE, $VERIFIER, ID_j, HID, CHA1, x_p, x_pv, rX1, sid),  // Consumed
    Generate_M(M),             // 
    Challenge(c2),             // 
    Unique(r2)                 //
  ]
  --[ Ver_Chain_2(ID_j, M, sid) ]->
  [ Out(<sid, ACK, M>),
    St_Ver_Chain_2($VERIFIER, $DEVICE, ID_j, HID, x_p, x_pv, c2, r2, M, sid)  // Linear state
  ]
// ---------------------------------------------------------------

// begin the mutual auth and key exchange

rule Mutual_Begin:
  let
    rx   = PUF(c2, r2)
    x_pv = H(<x_p, ID_j>)
    CHA = H(<rx, c2, x_pv>)
    Z    = ZK(M, rx, x)
  in
  [ In(<sid, e2, M>),
    St_Ver_Chain_2($VERIFIER, $DEVICE, ID_j, HID, x_p, x_pv, c2, r2, M, sid),  // Consumed
    Session_RND(x)             // Linear - fresh x for mutual auth
  ]
  --[ Mutual_Begin(ID_j, x, sid) ]->
  [ Out(<sid, CHA, Z, HID>),
    St_Mutual_Begin($DEVICE, $VERIFIER, ID_j, HID, x, Z, sid)  // Linear state
  ]

rule Mutual_InProcess:
  let
    MTL = H(<x, ID_j>)
  in
  [ In(<sid, CHA, Z, HID>),
    St_Mutual_Begin($DEVICE, $VERIFIER, ID_j, HID, x, Z, sid)  // Consumed
  ]
  --[ Mutual_InProcess(ID_j, Z, sid) ]->
  [ Out(<sid, MTL>),
    St_Mutual_InProcess($VERIFIER, $DEVICE, ID_j, MTL, sid)  // Linear state
  ]

rule Mutual_End:
  [ In(<sid, MTL>),
    St_Mutual_InProcess($VERIFIER, $DEVICE, ID_j, MTL, sid)  // Consumed
  ]
  --[ Mutual_End(ID_j, MTL, sid) ]->
  [ ]  // Protocol complete - no further state needed

// ---------------------------------------------------------------

/*
  Lemmas to test the backward secrecy. This lemma should be comment if want to validate other lemma except the backward secrecy
*/

/*
rule SessionLeak:
  [ Fr(x) ]  
  --[ SessionLeak(x) ]->
  [ Out(x) ]           // gives the attacker K(x)
*/


/*
This rule only activate when want to validate Forward Secrecy lemma. This lemma should be comment if want to validate other lemma except the backward secrecy
*/

/*
rule IDLeak:
//  [ !RegID($P, ID_j) ]
  [!Commit(ID_j, H(ID_j))]
  --[IDLeak(ID_j)]->
  [ Out(ID_j) ]
*/

// ****************************************************************************************************************************************************************************************

// **************************************************End of Rules**************************************************************************************************************************

// ****************************************************************************************************************************************************************************************

// Restrictions to ensure uniqueness and constrain state space

restriction Unique_Session:
  "All sid #i #j. SessionID(sid)@i & SessionID(sid)@j ==> #i = #j"

restriction Unique_Challenge:
  "All c #i #j. ChallengeGen(c)@i & ChallengeGen(c)@j ==> #i = #j"

restriction Unique_ID:
  "All id #i #j. IDCommit(id)@i & IDCommit(id)@j ==> #i = #j"

restriction Unique_M:
  "All M #i #j. GenerateM(M)@i & GenerateM(M)@j ==> #i = #j"

restriction Unique_SessionRND:
  "All x #i #j. SessionRND(x)@i & SessionRND(x)@j ==> #i = #j"

restriction Unique_Unique:
  "All r #i #j. UniqueGen(r)@i & UniqueGen(r)@j ==> #i = #j"

/*
    Group #1 Correctness / Key Establishment. This evaluation splitted into two lemmas for computational reason. Each lemma proves the protocol can progress through a particular (or the full) sequence of steps, i.e., that a full run is reachable and a key can in principle be established.
*/

lemma Correctness_Hello:
  exists-trace 
  "
  Ex ID_j x_p CHlen sid #t1 #t2.
    Prover_Hello(ID_j, x_p, sid) @ t1
    & Verifier_Hello(ID_j, CHlen, x_p, sid) @ t2
    & #t1 < #t2
  "

lemma Correctness_Hello_to_InChain:
  exists-trace 
  "
  Ex ID_j x_p x_pv rX CHlen sid #t1 #t2.
    Verifier_Hello(ID_j, CHlen, x_p, sid) @ t1
    &  Pr_Chain_1(ID_j, x_pv, rX, sid) @ t2
    & #t1 < #t2
  "
  
lemma Correctness_InChain:
  exists-trace 
  "
  Ex ID_j x_pv rX rX1 M CHA sid #t1 #t2 #t3 #t4.
    Pr_Chain_1(ID_j, x_pv, rX, sid) @ t1
    & Ver_Chain_1(ID_j, CHA, sid) @ t2
    & Pr_Chain_2(ID_j, x_pv, rX1, sid) @ t3
    & Ver_Chain_2(ID_j, M, sid) @ t4
    & #t1 < #t2
    & #t2 < #t3
    & #t3 < #t4
  "

lemma Correctness_Mutual:
  exists-trace 
  "
  Ex ID_j x Z MTL sid #t1 #t2 #t3.
    Mutual_Begin(ID_j, x, sid) @ t1
    & Mutual_InProcess(ID_j, Z, sid) @ t2
    & Mutual_End(ID_j, MTL, sid) @ t3
    & #t1 < #t2
    & #t2 < #t3
  "

lemma CorrectnessAll:
  exists-trace 
  "
  Ex ID_j x_p x_pv rX rX1 CHlen CHA x Z MTL M sid #t1 #t2 #t3 #t4 #t5 #t6 #t7 #t8 #t9.
    Prover_Hello(ID_j, x_p, sid) @ t1
    & Verifier_Hello(ID_j, CHlen, x_p, sid) @ t2
    & Pr_Chain_1(ID_j, x_pv, rX, sid) @ t3
    & Ver_Chain_1(ID_j, CHA, sid) @ t4
    & Pr_Chain_2(ID_j, x_pv, rX1, sid) @ t5
    & Ver_Chain_2(ID_j, M, sid) @ t6
    & Mutual_Begin(ID_j, x, sid) @ t7
    & Mutual_InProcess(ID_j, Z, sid) @ t8
    & Mutual_End(ID_j, MTL, sid) @ t9
    & #t1 < #t2
    & #t2 < #t3
    & #t3 < #t4
    & #t4 < #t5
    & #t5 < #t6
    & #t6 < #t7
    & #t7 < #t8
    & #t8 < #t9
  "

// ****************************************************************************************************************************************************************************************


/*
  Group #2 Mutual authentication (+ replay / impersonation). All these express that the prover and verifier agree on each otherâ€™s participation and prevent classic replay or impersonation variations.
*/
lemma Mutual_Auth:
  "
  All ID_j Z sid #t1.
    Mutual_InProcess(ID_j, Z, sid) @ t1
    ==> (Ex x #t2. Mutual_Begin(ID_j, x, sid) @ t2 & #t2 < #t1)
  "

lemma Mutual_Auth_2:
  "
  All ID_j MTL sid #t1.
    Mutual_End(ID_j, MTL, sid) @ t1
    ==> (Ex Z #t2. Mutual_InProcess(ID_j, Z, sid) @ t2 & #t2 < #t1) 
  " 

/* 
lemma No_Imper:
  "
  All ID_j Z sid #t1.
    Mutual_InProcess(ID_j, Z, sid) @ t1
    ==> (Ex ID_j x #t2. Mutual_Begin(ID_j, x, sid) @ t2 & #t2 < #t1)
  "

lemma No_Imper_2:
  "
  All ID_j MTL sid #t1.
    Mutual_End(ID_j, MTL, sid) @ t1
    ==> (Ex Z #t2. Mutual_InProcess(ID_j, Z, sid) @ t2 & #t2 < #t1) 
  "
*/

lemma Possible_Impersonation_Attack:  // should be return false
  exists-trace
  "
  Ex ID_j Z sid #t1.
    Mutual_InProcess(ID_j, Z, sid) @ t1
    & not (Ex x #t2. Mutual_Begin(ID_j, x, sid) @ t2 & #t2 < #t1)
  "

lemma No_Reuse:
  "
  All ID_j M sid #t1 #t2.
    Ver_Chain_2(ID_j, M, sid) @ t1
    & Ver_Chain_2(ID_j, M, sid) @ t2
    ==> #t1 = #t2
  "

/* 
lemma Replay_Attack:
    "
    All ID_j M sid #t1 #t2.
    Ver_Chain_2(ID_j, M, sid) @ t1
    & Ver_Chain_2(ID_j, M, sid) @ t2
    ==> #t1 = #t2
    "
*/


// ****************************************************************************************************************************************************************************************

/*
  Group #3 Confidentiality of session & long-term secrets. Each lemma says some secret (session key x, identity ID_j, derived values x_pv, rX) is never deducible by the attacker.

*/

lemma No_Sniff_X:
  "
  All ID_j x Z MTL sid #t1 #t2 #t3.
    Mutual_Begin(ID_j, x, sid) @ t1
    & Mutual_InProcess(ID_j, Z, sid) @ t2
    & Mutual_End(ID_j, MTL, sid) @ t3
    ==> not (Ex #t4. K(x) @t4)
  "
lemma Session_Secrecy:
  "
  All ID_j x sid #t1.
    Mutual_Begin(ID_j, x, sid) @ t1
    ==> not (Ex #t2. K(x) @ t2)
  "
/*
lemma Stolen_Ver:
  "
  All ID_j x sid #t1.
    Mutual_Begin(ID_j, x, sid) @ t1
    ==> not (Ex #t2. K(x) @ t2)
  "  
*/


lemma No_Sniff_IDj:
  "
  All ID_j x_p sid #t1.
    Prover_Hello(ID_j, x_p, sid) @ t1
    ==> not (Ex #t2. K(ID_j) @t2)
  "

lemma No_Sniff_xpv_r:
  "
  All ID_j x_pv rX CHA sid #t1 #t2.
    Pr_Chain_1(ID_j, x_pv, rX, sid) @ t1
    & Ver_Chain_1(ID_j, CHA, sid) @ t2
    ==> not (Ex #t3. K(x_pv) @t3 & K(rX) @t3)
  "

// ****************************************************************************************************************************************************************************************

/*
  Group #4 Perfect forward / backward secrecy. This lemma will be invalid or cannot be executed if the IDLeak and SessionLeak rules are not executed.
*/

/*
lemma Forward_Secrecy:
  "
  All ID_j x sid #t1 #t2.
    Mutual_Begin(ID_j, x, sid) @ t1
    & IDLeak(ID_j) @ t2
    & #t1 < #t2
    ==> not (Ex #t3. K(x) @ t3)
  "


lemma Backward_Secrecy:
  "
  All x_old  ID_new x_new sid_new  #t_leak #t_new.
     SessionLeak(x_old)                      @t_leak
   & Mutual_Begin(ID_new, x_new, sid_new) @t_new
   & #t_leak < #t_new                     // leak happens first
   ==> not (Ex #t. K(x_new) @ #t)         // attacker never learns new key
  "  
*/
// ****************************************************************************************************************************************************************************************


/*
  Group #6 Insider / MITM resistance
*/

lemma MITM_Resistance:
  "
  All ID1 ID2 Z x sid #t_ver #t_prov.
      Mutual_InProcess(ID1, Z,  sid) @ #t_ver
   &  Mutual_Begin   (ID2,  x,  sid) @ #t_prov
   ==> ID1 = ID2                     // session-binding forces same identity
  "

// ****************************************************************************************************************************************************************************************

/*
 Group #7 Privacy: anonymity / unlinkability. Together they state that observing one or two protocol runs does not reveal or link the proverâ€™s identity.

*/

lemma Unlinkability:
  "
  All ID1 ID2 Z1 Z2 sid1 sid2 #t1 #t2.
    Mutual_InProcess(ID1, Z1, sid1) @ t1
    & Mutual_InProcess(ID2, Z2, sid2) @ t2
    ==> (not (Ex #t3. K(ID1) @ t3)) & (not (Ex #t4. K(ID2) @ t4))
  "

lemma UnLink_Z_ID:
  "
  All ID_j Z sid #t1.
    Mutual_InProcess(ID_j, Z, sid) @ t1
    ==> not (Ex #t2. K(ID_j) @ t2)
  "

lemma ID_indisting:
  "
  All ID1 ID2 x_pv1 x_pv2 rX1 rX2 sid1 sid2 #t1 #t2.
    Pr_Chain_1(ID1, x_pv1, rX1, sid1) @ t1
    & Pr_Chain_1(ID2, x_pv2, rX2, sid2) @ t2
    ==> (not (Ex #t3. K(ID1) @ t3)) & (not (Ex #t4. K(ID2) @ t4))
  "

// ****************************************************************************************************************************************************************************************

/*
  Group #8 Non-repudiation. Ensures the verifierâ€™s evidence implies the prover really ran earlier.
*/

lemma Non_Repudiation:
  "
  All ID_j Z sid #t1.
    Mutual_InProcess(ID_j, Z, sid) @ t1
    ==> (Ex x #t2. Mutual_Begin(ID_j, x, sid) @ t2 & #t2 < #t1)
  "

// ****************************************************************************************************************************************************************************************


end
